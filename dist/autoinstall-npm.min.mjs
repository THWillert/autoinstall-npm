/**
 * @license MIT
 * @author Thorsten Willert
 * @version 1.1.0
 * 2024
 */ import e from"fs/promises";import{exec as t}from"child_process";import a from"path";import r from"yargs";import{hideBin as i}from"yargs/helpers";import o from"readline";import n from"chalk";function execShellCommand(e,a,r){return new Promise((i,o)=>{let n=t(e),l="";n.stdout.on("data",e=>{l+=e,a.write(e)}),n.stderr.on("data",e=>{r.write(e)}),n.on("close",e=>{0!==e?o(`Command failed with exit code ${e}`):i(l)})})}async function isLocalFile(t,r){let i=a.resolve(r,t);try{return await e.access(i),!0}catch{return!1}}async function findRequiredPackages(t,a){let r=await e.readFile(t,"utf8"),i=/import\s+\{[^}]*\}\s+from\s+['"]([^'"]+)['"]/g,o=/import\s+[^'"]*\s+from\s+['"]([^'"]+)['"]/g,n=/require\(['"]([^'"]+)['"]\)/g,l=/import\(['"]([^'"]+)['"]\)/g,s=new Set,c;for(;null!==(c=i.exec(r));)await isLocalFile(c[1],a)||s.add(c[1]);for(;null!==(c=o.exec(r));)await isLocalFile(c[1],a)||s.add(c[1]);for(;null!==(c=n.exec(r));)await isLocalFile(c[1],a)||s.add(c[1]);for(;null!==(c=l.exec(r));)await isLocalFile(c[1],a)||s.add(c[1]);return Array.from(s)}async function isPackageInstalled(e,t){if(t.has(e))return!0;try{let a=await execShellCommand(`npm list ${e}`,process.stdout,process.stderr),r=a.includes(e);return r&&t.add(e),r}catch{return!1}}function promptUser(e){let t=o.createInterface({input:process.stdin,output:process.stdout});return new Promise(a=>{t.question(e,e=>{t.close(),a("y"===e.toLowerCase())})})}async function checkAndInstallPackages(e,t,r,i){let o=a.dirname(e),l=await findRequiredPackages(e,o),s=[];for(let c of l)r.has(c)||await isPackageInstalled(c,i)||s.push(c);if(0===s.length){console.log(n.yellowBright(`No packages need to be installed for file: ${e}`));return}for(let d of(console.table(s.map(e=>({Package:e}))),s)){if(t){let f=await promptUser(`Install package ${d}? (yes/no): `);if(!f){console.log(n.yellow(`Skipping installation of ${d}`));continue}}console.log(n.cyan(`Package ${d} is not installed. Installing...`));let g=`sudo npm install ${d}`;try{await execShellCommand(g,process.stdout,process.stderr),console.log(n.green(`Successfully installed ${d}`)),r.add(d),i.add(d)}catch(m){console.error(n.red(`Failed to install ${d}: ${m}`))}}}async function processDirectory(t,r){let i=await e.readdir(t),o=i.filter(e=>e.endsWith(".js")||e.endsWith(".mjs")),l=new Set,s=new Set;for(let c of o){let d=a.join(t,c);console.log(n.magenta(`Processing file: ${d}`)),await checkAndInstallPackages(d,r,l,s),console.log(n.magenta(`Finished processing file: ${d}`))}}let argv=r(i(process.argv)).usage("Usage: $0 [-f <file> | -d <directory>] [--confirm]").option("f",{alias:"file",describe:"Path to a single Node.js file to analyze",type:"string",demandOption:!1}).option("d",{alias:"directory",describe:"Path to the directory to analyze",type:"string",demandOption:!1}).option("confirm",{describe:"Prompt for confirmation before installing each package",type:"boolean",default:!1}).help().argv,filePath=argv.file?a.resolve(argv.file):null,dirPath=argv.directory?a.resolve(argv.directory):null,promptForConfirmation=argv.confirm;if(filePath){console.log(n.magenta(`Processing file: ${filePath}`));let l=new Set,s=new Set;checkAndInstallPackages(filePath,promptForConfirmation,l,s).then(()=>console.log(n.green("Finished checking and installing packages for the file"))).catch(e=>console.error(n.red(e)))}else dirPath?processDirectory(dirPath,promptForConfirmation).then(()=>console.log(n.green("Finished checking and installing packages for all files"))).catch(e=>console.error(n.red(e))):console.error(n.red("You must provide either a file with -f or a directory with -d."));
